<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Manifesto | QAIL</title>
    <meta name="description"
        content="Why we built QAIL: Skip the string layer. AST to wire protocol bytes. The manifesto behind the vision.">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">

    <!-- Social Meta Tags -->
    <meta property="og:title" content="The Manifesto | QAIL">
    <meta property="og:description"
        content="The story of why we built QAIL. Solving the 'Database Dilemma' and escaping Polyglot Hell.">
    <meta property="og:image" content="https://qail-web.pages.dev/social_preview.svg">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Inter:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <!-- Navigation -->
    <div id="navbar"></div>

    <header class="page-header">
        <div class="container">
            <h1>The Manifesto</h1>
            <p class="subtitle">A story about the "Database Dilemma" and why we built QAIL.</p>
        </div>
    </header>

    <main class="page-content">
        <div class="container prose">
            <section>
                <h2>The Struggle: "Polyglot Hell"</h2>
                <p>We are polyglot developers. On Monday, we write <strong>Rust</strong>. On Tuesday,
                    <strong>Go</strong>. On Wednesday, we maintain a legacy <strong>PHP</strong> system.
                </p>
                <p>Every time we switch languages, we have to switch our paradigms:</p>
                <ul>
                    <li>In <strong>Rust</strong>, we choose between Diesel's strict compile-time types or SQLx's raw
                        flexibility.</li>
                    <li>In <strong>Go</strong>, we balance GORM's convenience with the performance of raw
                        <code>database/sql</code>.
                    </li>
                    <li>In <strong>Node.js</strong>, we rely on Prisma for safety but pay the cost of heavy binary
                        sidecars.</li>
                    <li>In <strong>Python</strong>, we leverage Django's speed of development but hit performance walls
                        at scale.</li>
                    <li>In <strong>PHP</strong>, we love Eloquent's expressiveness but sometimes need lighter, faster
                        query options.</li>
                </ul>
                <p><strong>The problem isn't the data. The problem is the interface.</strong> Why do we need to learn 5
                    different ways to say <code>SELECT * FROM users</code>?</p>
            </section>

            <section>
                <h2>The Origin: "I Don't Want You to Suffer"</h2>
                <blockquote class="manifesto-quote"
                    style="border-left-color: var(--accent-purple); background: rgba(168, 85, 247, 0.05);">
                    "I originally built QAIL for internal use to solve my own polyglot headaches. But I realized that
                    keeping it private meant letting other engineers suffer through the same 'Database Dilemma'. I
                    decided to open-source it so we can all skip the string layer."
                </blockquote>
            </section>

            <section>
                <h2>The Realization: "SQL is Assembly"</h2>
                <p>We realized something profound: <strong>SQL is not source code. SQL is Assembly.</strong></p>
                <p>SQL is verbose, powerful, and dangerous. It is the low-level instruction set of the database engine.
                </p>
                <ul>
                    <li><strong>Raw SQL</strong> offers ultimate control, but maintaining raw strings across a large
                        codebase requires immense discipline.</li>
                    <li><strong>ORMs</strong> provide fantastic productivity, but the abstraction sometimes comes at the
                        cost of fine-grained performance control.</li>
                </ul>
                <p>We didn't need a compromise. We needed a <strong>Universal AST</strong>.</p>
            </section>

            <section>
                <h2>The Savior: QAIL</h2>
                <p>QAIL is the "Universal AST for Databases". It is not a text syntax that compiles to SQL—it is a
                    native data structure that encodes directly to database wire protocols.</p>
                <p>It separates the <strong>Code</strong> (your query AST) from the <strong>Data</strong> (your
                    parameters). It creates a unified structure that works the same way in Rust, Go, Node, and PHP.</p>

                <div class="comparison-grid">
                    <div class="code-block qail">
                        <small>Build This (Rust)</small>
                        <code>QailCmd::get("users")
    .columns(["id", "email"])
    .filter("active", Eq, true)
    .limit(10)</code>
                    </div>
                    <div class="code-block sql">
                        <small>Encodes To (Wire Protocol)</small>
                        <code>SELECT id, email FROM users WHERE active = true LIMIT 10</code>
                    </div>
                </div>

                <p>Now, your team builds with <strong>one AST</strong>. The Rust dev, the Go dev, and the Frontend dev
                    all
                    use the same data structure.</p>

                <blockquote class="manifesto-quote">
                    "Safety shouldn't require a prison of boilerplate. We moved validation from the 'String' layer to
                    the 'AST' layer. Code is data. Data is typed. Injection is structurally impossible."
                </blockquote>

                <p>By preventing SQL injection at the <strong>AST level</strong>, QAIL ensures your queries are safe
                    before they even reach the database. Unlike ORMs that generate strings at runtime, QAIL encodes
                    directly to wire protocol bytes—<strong>no string layer at all</strong>.</p>
            </section>

            <section>
                <h2>The Architecture: Native Power</h2>
                <p>QAIL is written in <strong>Pure Rust</strong>. It exposes:</p>
                <ul>
                    <li><strong>A C-API</strong> for Go, Python, and Java (via FFI).</li>
                    <li><strong>A WASM Module</strong> for Node.js and Browsers.</li>
                    <li><strong>A Native Crate</strong> for Rust users.</li>
                </ul>
                <p>It runs in-process. It has zero network overhead. It turns your query generation into a simple CPU
                    function call.</p>
            </section>

            <hr style="margin: 3rem 0; opacity: 0.1;">

            <section>
                <h2>The AST Builder API</h2>
                <p>We designed the builder API for <strong>Type Safety and Clarity.</strong> Every method is purposeful.
                    No
                    strings to parse.</p>
                <table style="width: 100%; margin: 1rem 0;">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Purpose</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>QailCmd::get()</code></td>
                            <td>SELECT query</td>
                            <td><code>QailCmd::get("users")</code></td>
                        </tr>
                        <tr>
                            <td><code>.columns()</code></td>
                            <td>Select specific columns</td>
                            <td><code>.columns(["id", "email"])</code></td>
                        </tr>
                        <tr>
                            <td><code>.filter()</code></td>
                            <td>WHERE condition</td>
                            <td><code>.filter("active", Eq, true)</code></td>
                        </tr>
                        <tr>
                            <td><code>.order_by()</code></td>
                            <td>Sort results</td>
                            <td><code>.order_by("created_at", Desc)</code></td>
                        </tr>
                        <tr>
                            <td><code>.limit()</code></td>
                            <td>Pagination</td>
                            <td><code>.limit(10)</code></td>
                        </tr>
                        <tr>
                            <td><code>.left_join()</code></td>
                            <td>Join tables</td>
                            <td><code>.left_join("profiles", "users.id", "profiles.user_id")</code></td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </div>
    </main>

    <!-- Footer -->
    <div id="footer"></div>

    <script src="components.js"></script>
    <script src="script.js"></script>
</body>

</html>